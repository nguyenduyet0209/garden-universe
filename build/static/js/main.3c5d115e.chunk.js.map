{"version":3,"sources":["utils/sesstionStorage.js","app/slices/authSlice.js","context/AppProvider.jsx","app/hook.js","views/components/Loading/Loading.jsx","views/pages/NoMatch/NoMatch.jsx","routes/routes.js","routes/PrivateRoute.jsx","App.js","app/store.js","serviceWorker.js","index.js"],"names":["setAuthToSession","accessToken","ethAddress","nonce","sessionStorage","setItem","getAccessTokenInSession","getItem","getEthAddressInSession","getNonceInSession","resetSession","clear","authSliceReducer","createSlice","name","initialState","isConnecting","reducers","setAuth","state","payload","setIsConnecting","resetAuth","resetIsConnecting","actions","AppContext","createContext","AppProvider","children","useState","isDepositVisible","setIsDepositVisible","isWithdrawVisible","setIsWithdrawVisible","Provider","value","useAppDispatch","useDispatch","useAppSelector","useSelector","Loading","className","NoMatch","routeConfig","id","path","component","lazy","isProtected","PrivateRoute","location","useLocation","auth","to","from","replace","App","fallback","map","route","element","store","configureStore","reducer","middleware","getDefaultMiddleware","concat","Boolean","window","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3c5d115e.chunk.js","sourcesContent":["// GET KEY TO SESSION\nexport function setAccessTokenToSession(accessToken) {\n  sessionStorage.setItem('ACCESS_TOKEN', accessToken)\n}\n\nexport function setEthAddressToSession(ethAddress) {\n  sessionStorage.setItem('ETH_ADDRESS', ethAddress)\n}\n\nexport function setNonceToSession(nonce) {\n  sessionStorage.setItem('NONCE', nonce)\n}\n\nexport function setAuthToSession({ accessToken, ethAddress, nonce }) {\n  sessionStorage.setItem('ACCESS_TOKEN', accessToken)\n  sessionStorage.setItem('ETH_ADDRESS', ethAddress)\n  sessionStorage.setItem('NONCE', nonce)\n}\n\nexport function setSignatureToSession(signature) {\n  sessionStorage.setItem('SIGNATURE', signature)\n}\n\n// GET KEY IN SESSION\nexport function getAccessTokenInSession() {\n  return sessionStorage.getItem('ACCESS_TOKEN')\n}\n\nexport function getEthAddressInSession() {\n  return sessionStorage.getItem('ETH_ADDRESS')\n}\n\nexport function getNonceInSession() {\n  return sessionStorage.getItem('NONCE')\n}\n\nexport function getSignatureInSession() {\n  return sessionStorage.getItem('SIGNATURE')\n}\n\nexport function resetSession() {\n  sessionStorage.clear()\n}\n","import { createSlice } from '@reduxjs/toolkit'\nimport {\n  getAccessTokenInSession,\n  getEthAddressInSession,\n  getNonceInSession,\n} from '../../utils/sesstionStorage'\n\nconst authSliceReducer = createSlice({\n  name: 'auth',\n  initialState: {\n    accessToken: getAccessTokenInSession() || null,\n    ethAddress: getEthAddressInSession() || null,\n    nonce: getNonceInSession() || null,\n    isConnecting: false,\n  },\n  reducers: {\n    setAuth: (state, { payload: { accessToken, ethAddress, nonce } }) => {\n      state.accessToken = accessToken\n      state.ethAddress = ethAddress\n      state.nonce = nonce\n    },\n    setIsConnecting: (state) => {\n      state.isConnecting = true\n    },\n    resetAuth: (state) => {\n      state.accessToken = null\n      state.ethAddress = null\n      state.nonce = null\n    },\n    resetIsConnecting: (state) => {\n      state.isConnecting = false\n    },\n  },\n})\nexport const { setAuth, setIsConnecting, resetAuth, resetIsConnecting } =\n  authSliceReducer.actions\nexport default authSliceReducer.reducer\n","import React, { createContext, useState } from 'react'\nimport PropTypes from 'prop-types'\n\nexport const AppContext = createContext()\n\nexport default function AppProvider({ children }) {\n  const [isDepositVisible, setIsDepositVisible] = useState(false)\n  const [isWithdrawVisible, setIsWithdrawVisible] = useState(false)\n\n  return (\n    <AppContext.Provider\n      value={{\n        isDepositVisible,\n        setIsDepositVisible,\n        isWithdrawVisible,\n        setIsWithdrawVisible,\n      }}\n    >\n      {children}\n    </AppContext.Provider>\n  )\n}\n\nAppProvider.propTypes = {\n  children: PropTypes.element,\n}\n","import { useDispatch, useSelector } from 'react-redux'\n\nexport const useAppDispatch = () => useDispatch()\nexport const useAppSelector = useSelector\n","import './style.scss'\n\nexport function Loading() {\n  return (\n    <div className=\"loading-component\">\n      <div className=\"lds-default\">\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n      </div>\n    </div>\n  )\n}\n","import React from 'react'\n\nexport default function NoMatch() {\n  return <div>NoMatch</div>\n}\n","import { lazy } from 'react'\n\nexport const routeConfig = [\n  {\n    id: 'HomePage',\n    path: '/',\n    component: lazy(() => import('../views/pages/HomePage/HomePage')),\n    isProtected: false,\n  },\n  {\n    id: 'ProfilePage',\n    path: '/profile',\n    component: lazy(() => import('../views/pages/Profile/Profile')),\n    isProtected: true,\n  },\n]\n","import PropTypes from 'prop-types'\n\nimport { Navigate, useLocation } from 'react-router-dom'\nimport { useAppSelector } from '../app/hook'\n\nexport default function PrivateRoute({ children }) {\n  const location = useLocation()\n\n  const { accessToken } = useAppSelector((state) => state.auth)\n\n  if (!accessToken) {\n    return <Navigate to=\"/\" state={{ from: location }} replace />\n  }\n\n  return <>{children}</>\n}\n\nPrivateRoute.propTypes = {\n  children: PropTypes.element.isRequired,\n}\n","import React, { Suspense } from 'react'\nimport { Route, Routes } from 'react-router-dom'\n\nimport { Loading } from './views/components/Loading/Loading'\nimport NoMatch from './views/pages/NoMatch/NoMatch'\nimport { routeConfig } from './routes/routes'\nimport AppProvider from './context/AppProvider'\nimport PrivateRoute from './routes/PrivateRoute'\n\nfunction App() {\n  return (\n    <AppProvider>\n      <div className=\"wrapper\">\n        <main>\n          <Suspense fallback={<Loading />}>\n            <Routes>\n              {routeConfig.map((route) => (\n                <Route\n                  key={route.id}\n                  path={route.path}\n                  element={\n                    route.isProtected ? (\n                      <PrivateRoute>\n                        <route.component />\n                      </PrivateRoute>\n                    ) : (\n                      <route.component />\n                    )\n                  }\n                />\n              ))}\n\n              <Route path=\"*\" element={<NoMatch />} />\n            </Routes>\n          </Suspense>\n        </main>\n      </div>\n    </AppProvider>\n  )\n}\n\nexport default App\n","import { configureStore } from '@reduxjs/toolkit'\nimport authSliceReducer from './slices/authSlice'\n\nexport const store = configureStore({\n  reducer: {\n    auth: authSliceReducer,\n  },\n\n  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(),\n})\n\n// optional, but required for refetchOnFocus/refetchOnReconnect behaviors\n// see `setupListeners` docs - takes an optional callback as the 2nd arg for customization\n// setupListeners(store.dispatch)\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport { store } from './app/store'\nimport { Provider } from 'react-redux'\nimport * as serviceWorker from './serviceWorker'\nimport { BrowserRouter } from 'react-router-dom'\n\nimport 'antd/dist/antd.css'\nimport './assets/styles/main.scss'\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <BrowserRouter>\n        <App />\n      </BrowserRouter>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}